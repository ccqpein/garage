* Auto generate the API document from golang handler code

+ this demo is not generate the api spec doc, instead, it uses it.
+ this demo generate the some nautral language describe the api which I can put them in doc and readme

  
** Components

*** get the functions call tree

I want to use the golang lsp (gopls) to get the refs of function. Like generate the tree of function call inside. 3 levels deeper.

this can be the general feature not only for the api generated, but also the for the some "what's this function do" stuff.

*advance:*

- [ ] control the tree deep level to control how many functions context to send to llm

*** read the api spec

need this to get more details of this api. let's say api spec is json for now. 

*** read the handers 

llm filters the api endpoints register. get the handler function, then can call the function tree getter to get the all functions behind. wrap them as functions context

meanwhile, query the api spec for this endpoint.

then send them to llm get the api doc

** llm involve

several parts llm will involve:

+ read handlers registers code, get the hander function and their related endpoint.
+ use api spec of the endpoint and the function call tree to generate the doc

llm can be open source llm, no need to call the online payed api.

** Executive entry

go generate call the entry function.

** Run it

one docker compose should good for everything

* Developing

** gopls issue

test gopls in shell and find it can find the defination of function but only give the locaiton (row number). So I maybe need some other easy way to get the whole function. Then need to pick the function call from the whole function body.

So now, I actually get more features need to handle that get the whole function with the name and pick all other functions call inside. 


* Run

#+begin_src shell
  go run ./doc-generater-demo ./demo-server/main.go registerRoutes
#+end_src

#+begin_quote
func registerRoutes() {
	http.HandleFunc("/products", productsHandler) // Use a multiplexer for /products and /products/{id}
}, 221
llmResp: [{"endpoint": "/products", "funcName": "productsHandler"}]
[{Endpoint:/products Funcname:productsHandler}]
start to doc the endpoint: {Endpoint:/products Funcname:productsHandler}
func /products rn 1 cn 31
outputStr: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go:180:6-21: defined here as func productsHandler(w http.ResponseWriter, r *http.Request)
productsHandler acts as a simple router for /products and /products/{id}.
File Path: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go
Line: 180
Column: 6
Extracted: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go 180 6
llmResp: ["getProductsHandler","createProductHandler","getProductByIDHandler","updateProductHandler","deleteProductHandler"]
outputStr: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go:48:6-24: defined here as func getProductsHandler(w http.ResponseWriter, r *http.Request)
getProductsHandler returns a list of all products.
File Path: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go
Line: 48
Column: 6
Extracted: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go 48 6
outputStr: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go:93:6-26: defined here as func createProductHandler(w http.ResponseWriter, r *http.Request)
createProductHandler creates a new product.
File Path: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go
Line: 93
Column: 6
Extracted: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go 93 6
outputStr: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go:67:6-27: defined here as func getProductByIDHandler(w http.ResponseWriter, r *http.Request)
getProductByIDHandler returns a single product by its ID.
File Path: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go
Line: 67
Column: 6
Extracted: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go 67 6
outputStr: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go:120:6-26: defined here as func updateProductHandler(w http.ResponseWriter, r *http.Request)
updateProductHandler updates an existing product by ID.
File Path: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go
Line: 120
Column: 6
Extracted: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go 120 6
outputStr: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go:155:6-26: defined here as func deleteProductHandler(w http.ResponseWriter, r *http.Request)
deleteProductHandler deletes a product by its ID.
File Path: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go
Line: 155
Column: 6
Extracted: ~/Code/garage/ai/rest-api-document-golang/demo-server/main.go 155 6
doc for endpoint /products:
Overview
The productsHandler function is a single entry point that routes HTTP requests for the /products resource to the appropriate CRUD handlers based on the request path and method. It distinguishes between collection-level operations (/products) and item-level operations (/products/{id}).

What it routes
- Collection endpoint (/products):
  - GET /products → getProductsHandler
    - Expected to return a list of products.
  - POST /products → createProductHandler
    - Expected to create a new product from the request body.

- Item endpoint (/products/{id}):
  - GET /products/{id} → getProductByIDHandler
    - Expected to return a single product by ID.
  - PUT /products/{id} → updateProductHandler
    - Expected to update an existing product by ID using the request body.
  - DELETE /products/{id} → deleteProductHandler
    - Expected to delete a product by ID.
  - Other methods on /products/{id} → 405 Method Not Allowed with message "Method not allowed for product ID endpoints".

How the path matching works
- Exact matches:
  - If path is exactly "/products" and method is GET or POST, it routes to list or create respectively.
  - If path is exactly "/products/" and method is GET, PUT, or DELETE, it routes to the respective by-ID handlers (the by-ID handler is responsible for extracting the ID from the path).

- Generic fallback for /products/{id}:
  - If none of the exact cases matched, it checks whether the path starts with "/products/" and has a non-empty remainder (e.g., "/products/123").
  - If so, it routes by method:
    - GET → getProductByIDHandler
    - PUT → updateProductHandler
    - DELETE → deleteProductHandler
    - Otherwise → 405 for item endpoints.

Notes and behaviors to be aware of
- ID extraction and validation are not done in productsHandler; the called handlers are expected to parse and validate the {id} segment from r.URL.Path.
- Only the following methods are allowed:
  - On /products: GET, POST.
  - On /products/{id}: GET, PUT, DELETE.
- Unsupported methods for item endpoints return 405 with a clear error message. Unsupported methods for the collection endpoint are not explicitly handled here and will fall through to the default block; the intended behavior is to allow only GET/POST on /products.
- Trailing slash handling:
  - The code includes cases for "/products" and "/products/" separately. The comments note reliance on the default http.ServeMux longest-prefix matching. In practice, the generic fallback is what ensures that paths like "/products/123" are routed to the by-ID handlers.
- The routing does not validate that the segment after "/products/" is a single ID; any non-empty remainder is treated as an ID path and delegated to the by-ID handlers to decide.

Responsibilities of the called handlers
- getProductsHandler(w, r):
  - Reads query parameters as needed (if any), retrieves and returns the list of products.
- createProductHandler(w, r):
  - Reads and validates the request body, creates a product, returns the created resource or appropriate status.
- getProductByIDHandler(w, r):
  - Extracts the ID from the path, fetches the product, returns it or a not-found/error response.
- updateProductHandler(w, r):
  - Extracts the ID and reads the request body, validates and updates the product, returns the updated resource or appropriate status.
- deleteProductHandler(w, r):
  - Extracts the ID, deletes the product, returns a success/no-content or not-found/error response.
#+end_quote


#+begin_src shell
go run . ../demo-server/main.go registerRoutes2
#+end_src

#+begin_quote
doc for endpoint /health:
Human-readable documentation for /health handler

- Endpoint: /health
- Handler: healthCheckHandler
- Purpose: Enforces that the /health endpoint is accessed with the GET HTTP method.

Behavior:
- Accepts only GET requests.
- If the request method is anything other than GET:
  - Responds with HTTP 405 Method Not Allowed.
  - Response body: "Method not allowed" (plain text).
  - Processing stops immediately.

Notes:
- The error response is produced via http.Error, which writes a plain-text message and sets the status code.
- The snippet does not show what happens for valid GET requests. If there is no additional code, the handler would return a 200 OK with an empty body by default when it returns without writing a response. If more logic exists below this check, that logic would define the actual health response (e.g., "OK", JSON status, etc.).

doc for endpoint /products:
Human-readable documentation: /products API handler

Purpose
- productsHandler is a single HTTP handler that routes requests for the products resource to the appropriate sub-handler based on the request path and method.

Supported routes and behavior
- Collection routes (/products)
  - GET /products → getProductsHandler
    - Typical intent: return a list of products.
  - POST /products → createProductHandler
    - Typical intent: create a new product from the request body.

- Item routes (/products/{id})
  - GET /products/{id} → getProductByIDHandler
    - Typical intent: return a single product by its ID.
  - PUT /products/{id} → updateProductHandler
    - Typical intent: update an existing product identified by ID with data from the request body.
  - DELETE /products/{id} → deleteProductHandler
    - Typical intent: delete the product identified by ID.

How routing works
- Exact-path matches:
  - If r.URL.Path is exactly "/products" and method is GET → getProductsHandler.
  - If r.URL.Path is exactly "/products" and method is POST → createProductHandler.
  - The code also checks for r.URL.Path == "/products/" with GET/PUT/DELETE, but those cases won’t actually match item paths like "/products/123" (they only match the exact string "/products/"). Real item routing is handled by the generic fallback described next.

- Generic fallback for item routes:
  - For any other path, the handler attempts to treat it as an item route if it starts with "/products/":
    - It slices the URL after "/products/" and, if there is at least one character remaining (i.e., an ID segment), it dispatches based on method:
      - GET → getProductByIDHandler
      - PUT → updateProductHandler
      - DELETE → deleteProductHandler
      - Any other method → responds with 405 Method Not Allowed and message "Method not allowed for product ID endpoints".

Functions called and their intended roles
- getProductsHandler(w, r)
  - Handles GET /products.
  - Expected to read any query parameters (if supported), fetch and return the list of products.

- createProductHandler(w, r)
  - Handles POST /products.
  - Expected to parse the request body (typically JSON), validate input, create a new product, and return the created resource or an appropriate status.

- getProductByIDHandler(w, r)
  - Handles GET /products/{id}.
  - Expected to extract the {id} from the URL path, fetch the product, and return it or a not-found error.

- updateProductHandler(w, r)
  - Handles PUT /products/{id}.
  - Expected to extract {id}, parse and validate the request body, update the product, and return the updated resource or an appropriate status.

- deleteProductHandler(w, r)
  - Handles DELETE /products/{id}.
  - Expected to extract {id}, delete the product, and return a success status (often 204 No Content) or a not-found error.

Method allowance and error handling
- On /products:
  - Allowed methods: GET, POST.
  - Other methods are not explicitly handled in this code path.

- On /products/{id}:
  - Allowed methods: GET, PUT, DELETE.
  - Any other method returns 405 Method Not Allowed with a clear error message.

Notes and caveats (based strictly on the provided code)
- The exact-match cases for r.URL.Path == "/products/" labeled to “catch /products/{id}” will not match item paths like "/products/123"; actual item routing is done in the generic fallback.
- The generic fallback assumes the path starts with "/products/". If this handler is ever invoked for a path shorter than that or not starting with that prefix, the string slicing operation r.URL.Path[len("/products/"):] could be unsafe. In typical net/http ServeMux setups where this handler is only mounted on "/products" and/or "/products/", this is less likely, but it’s worth noting.
- For methods other than GET/POST on exactly "/products", the code falls through to the fallback logic rather than returning a clear 405 for the collection endpoint. Depending on how the handler is mounted, this could result in a method-not-allowed response for item endpoints or an unintended error.

doc for endpoint /products/:
Human-readable documentation for /products handler

Overview
- This handler routes HTTP requests for the Product resource under the /products path.
- It delegates to specific handlers based on the request path and method.
- It relies on Go’s net/http default ServeMux “longest match” behavior for prefix routes.

Endpoints and behavior
1) GET /products
- Action: List all products.
- Handler called: getProductsHandler(w, r).
- Only GET is allowed here (see caveats for unsupported methods).

2) POST /products
- Action: Create a new product.
- Handler called: createProductHandler(w, r).
- Only POST is allowed here (see caveats for unsupported methods).

3) GET /products/{id}
- Action: Fetch a single product by ID.
- Handler called: getProductByIDHandler(w, r).
- Resolved via the default branch that detects a non-empty segment after /products/.

4) PUT /products/{id}
- Action: Update a product by ID.
- Handler called: updateProductHandler(w, r).
- Resolved via the default branch that detects a non-empty segment after /products/.

5) DELETE /products/{id}
- Action: Delete a product by ID.
- Handler called: deleteProductHandler(w, r).
- Resolved via the default branch that detects a non-empty segment after /products/.

Method restrictions and errors
- For /products/{id}:
  - If the method is not GET, PUT, or DELETE, the handler returns 405 Method Not Allowed with message: "Method not allowed for product ID endpoints".
- For /products (no ID):
  - Intended behavior: allow only GET and POST.
  - See caveats below for what actually happens with unsupported methods.

How routing is determined
- First, the handler checks for exact matches:
  - r.URL.Path == "/products" and method GET -> list products.
  - r.URL.Path == "/products" and method POST -> create product.
  - r.URL.Path == "/products/" and method GET/PUT/DELETE -> intended for by-ID, but equality match means it only matches exactly "/products/", not "/products/{id}".
- If none of the above matches, it falls into the default branch:
  - It computes the path segment after "/products/".
  - If that segment is non-empty, it treats the request as a by-ID endpoint and dispatches based on method (GET/PUT/DELETE).
  - Otherwise, it responds with 405 for unsupported methods on by-ID endpoints; see caveats for empty segments.

Important caveats and edge cases
- Unsupported method on /products causes a bug:
  - In the default branch, the code slices r.URL.Path using len("/products/"). If the path is exactly "/products" (shorter than "/products/"), this will panic (index out of range).
  - Example: PATCH /products would hit the default branch and likely panic.
  - Suggested fix: check prefix safely (e.g., strings.HasPrefix), or handle "/products" explicitly for unsupported methods and return 405.
- Exact "/products/" without an ID:
  - The equality checks for "/products/" suggest it would route GET/PUT/DELETE to by-ID handlers, but because there is no ID segment, those handlers likely won’t find an ID.
  - In the default branch, when the segment after "/products/" is empty, no by-ID handler is called; the code as shown doesn’t send a response for this case. This can lead to a hanging request or implicit 200 with empty body, depending on surrounding code.
  - Suggested fix: if the segment after "/products/" is empty, return 404 Not Found or 405 Method Not Allowed with a clear message.
- Relying on equality for "/products/" won’t match "/products/{id}":
  - The equality checks cannot catch paths with an ID. The actual routing for by-ID paths relies solely on the default branch and the “segment after /products/ is non-empty” logic.
- Trailing slashes:
  - /products and /products/ are treated differently in the equality checks. Ensure clients use the documented forms (/products for collection; /products/{id} for single resource) to avoid ambiguity.

Example usage (generic)
- List products: GET /products
- Create product: POST /products
- Get a product: GET /products/123
- Update a product: PUT /products/123
- Delete a product: DELETE /products/123

Return formats and payloads
- Not defined in the provided code. The specific JSON schemas and status codes (e.g., 200, 201, 204, 404) depend on the implementations of:
  - getProductsHandler
  - createProductHandler
  - getProductByIDHandler
  - updateProductHandler
  - deleteProductHandler

Summary
- Collection endpoint (/products): supports GET and POST.
- Item endpoint (/products/{id}): supports GET, PUT, DELETE.
- 405 is returned for unsupported methods on item endpoints. Unsupported methods on the collection endpoint currently risk a runtime panic and should be handled explicitly.
#+end_quote
