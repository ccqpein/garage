// generated by AI
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"sync"
)

// Product represents a product in our simplified inventory system.
type Product struct {
	ID    string  `json:"id"`
	Name  string  `json:"name"`
	Price float64 `json:"price"`
	Stock int     `json:"stock"`
}

// In-memory store for products.
var (
	products = make(map[string]Product)
	nextID   = 1
	mu       sync.Mutex // Mutex to protect access to 'products' map and 'nextID'
)

func init() {
	// Initialize with some dummy data
	mu.Lock()
	defer mu.Unlock()
	products["1"] = Product{ID: "1", Name: "Laptop", Price: 1200.00, Stock: 50}
	products["2"] = Product{ID: "2", Name: "Mouse", Price: 25.00, Stock: 200}
	nextID = 3
}

// healthCheckHandler responds with a simple "OK" to indicate server health.
func healthCheckHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	w.WriteHeader(http.StatusOK)
	fmt.Fprint(w, "OK")
}

// getProductsHandler returns a list of all products.
func getProductsHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	mu.Lock()
	defer mu.Unlock()

	productList := []Product{}
	for _, p := range products {
		productList = append(productList, p)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(productList)
}

// getProductByIDHandler returns a single product by its ID.
func getProductByIDHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	id := r.URL.Path[len("/products/"):] // Extract ID from path
	if id == "" {
		http.Error(w, "Product ID is required", http.StatusBadRequest)
		return
	}

	mu.Lock()
	defer mu.Unlock()

	product, ok := products[id]
	if !ok {
		http.Error(w, "Product not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(product)
}

// createProductHandler creates a new product.
func createProductHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var newProduct Product
	err := json.NewDecoder(r.Body).Decode(&newProduct)
	if err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	mu.Lock()
	defer mu.Unlock()

	newID := strconv.Itoa(nextID)
	nextID++
	newProduct.ID = newID
	products[newID] = newProduct

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(newProduct)
}

// updateProductHandler updates an existing product by ID.
func updateProductHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPut {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	id := r.URL.Path[len("/products/"):] // Extract ID from path
	if id == "" {
		http.Error(w, "Product ID is required", http.StatusBadRequest)
		return
	}

	var updatedProduct Product
	err := json.NewDecoder(r.Body).Decode(&updatedProduct)
	if err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	mu.Lock()
	defer mu.Unlock()

	if _, ok := products[id]; !ok {
		http.Error(w, "Product not found", http.StatusNotFound)
		return
	}

	updatedProduct.ID = id // Ensure the ID in the body matches the path ID
	products[id] = updatedProduct

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updatedProduct)
}

// deleteProductHandler deletes a product by its ID.
func deleteProductHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodDelete {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	id := r.URL.Path[len("/products/"):] // Extract ID from path
	if id == "" {
		http.Error(w, "Product ID is required", http.StatusBadRequest)
		return
	}

	mu.Lock()
	defer mu.Unlock()

	if _, ok := products[id]; !ok {
		http.Error(w, "Product not found", http.StatusNotFound)
		return
	}

	delete(products, id)
	w.WriteHeader(http.StatusNoContent)
}

// productsHandler acts as a simple router for /products and /products/{id}.
func productsHandler(w http.ResponseWriter, r *http.Request) {
	switch {
	case r.URL.Path == "/products" && r.Method == http.MethodGet:
		getProductsHandler(w, r)
	case r.URL.Path == "/products" && r.Method == http.MethodPost:
		createProductHandler(w, r)
	case r.URL.Path == "/products/" && r.Method == http.MethodGet: // This will catch GET /products/{id}
		getProductByIDHandler(w, r)
	case r.URL.Path == "/products/" && r.Method == http.MethodPut: // This will catch PUT /products/{id}
		updateProductHandler(w, r)
	case r.URL.Path == "/products/" && r.Method == http.MethodDelete: // This will catch DELETE /products/{id}
		deleteProductHandler(w, r)
	default:
		// Attempt to handle paths like /products/{id} more generically if the exact prefix match fails
		// The default http.ServeMux will try the longest match.
		// For /products/1, http.HandleFunc("/products/", ...) will match.
		// For /products, http.HandleFunc("/products", ...) will match.
		// The custom logic above explicitly handles methods for those matches.
		// If it's a direct /products call, only allow GET/POST.
		// If it's a /products/ID call, only allow GET/PUT/DELETE.
		pathSegments := r.URL.Path[len("/products/"):]
		if len(pathSegments) > 0 { // It has an ID segment
			switch r.Method {
			case http.MethodGet:
				getProductByIDHandler(w, r)
			case http.MethodPut:
				updateProductHandler(w, r)
			case http.MethodDelete:
				deleteProductHandler(w, r)
			default:
				http.Error(w, "Method not allowed for product ID endpoints", http.StatusMethodNotAllowed)
			}
		} else { // It's /products without an ID
			http.Error(w, "Method not allowed or endpoint not found", http.StatusMethodNotAllowed)
		}
	}
}

// registerRoutes registers all API endpoints.
//
//go:generate ../doc-generater-demo/doc-generater-demo $GOFILE registerRoutes
func registerRoutes() {
	http.HandleFunc("/products", productsHandler) // Use a multiplexer for /products and /products/{id}
}

// func registerRoutes() {
// 	http.HandleFunc("/health", healthCheckHandler)
// 	http.HandleFunc("/products", productsHandler) // Use a multiplexer for /products and /products/{id}
// 	http.HandleFunc("/products/", productsHandler)
// }

func main() {
	registerRoutes()
	port := ":8080"
	log.Printf("Server starting on port %s...", port)
	log.Fatal(http.ListenAndServe(port, nil)) // nil uses the default ServeMux
}
