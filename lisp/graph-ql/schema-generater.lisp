(defclass query-schema ()
  (
   (fields
	:initarg :fields
	:accessor fields)
   )
  (:documentation "the root query schema class"))

(defclass mutation-schema ()
  (
   (fields
	:initarg :fields
	:accessor fields)
   )
  (:documentation "the root mutation schema class")
  )

(defmacro defstruct-with-query-schema (name-and-options &rest slot-descriptions)
  "defstruct and generate the query schema"
  (let (name fields)
	(if (consp name-and-options)
		(setf name (car name-and-options))
		(setf name name-and-options))

	(loop for f in slot-descriptions
		  if (consp f)
			do (push (car f) fields)
		  else
			do (push f fields))
	
	(let ((schema-class-name (read-from-string (str:concat (symbol-name name) "-QUERY-SCHEMA"))))
	  `(progn
		 (defstruct ,name-and-options ,@slot-descriptions)
	   
		 (defclass ,schema-class-name (query-schema)
		   (
			(default-data-fetcher
			 :initarg :default-data-fetcher
			 :accessor default-data-fetcher
			 :documentation "function for fetching the data")

			(default-filter
			 :initarg :default-filter
			 :accessor default-filter
			 :documentation "function for filtering data after fetched")
			)
		  
		   (:documentation ,(format nil "autogenerated query-schema for ~a" name)))

		 ;;:= maybe need prepare
		 
		 (defmethod query ((s ,schema-class-name)
						   &rest keys
						   &key ,@fields &allow-other-keys)
		   ;; fetch the data, set fetcher with query
		   ;; want cache? use :before query method
		   ;; (let* ((data (apply (if data-fetcher (data-fetcher s) (default-data-fetcher s)) keys))
		   ;; 		  ;; filter the data
		   ;; 		  (results (apply (if filter (filter s) (default-filter s)) data keys)))
		   ;; 	 results)
		   )

		 (defmethod resolve ((s ,schema-class-name) fields)
		   "parse the scaner block of received schema to data-filter"
		   (if (string/= ,name (car fields))
			   (error 'resolver-wrong-schema :suppose-name ,name :actually-name (car fields)))

		   (let (fields-block arguments-block)
			 
			 ;; assign arguments block and fields block
			 (if (c2mop:subclassp (nth 1 fields) 'parenthesis-scanner)
				 (setf arguments-block (schema-values (cadr fields))))
			 (if (not arguments-block)
				 (setf fields-block (schema-values (cadr fields)))
				 (setf fields-block (schema-values (caddr fields))))

			 ;;:= TODO: return the arguments-block and fields-block
			 )
		   )
		 ))))


(defmacro generate-mutation-schema ()
  "generate the mutation schema for structure"
  ;;:= todo
  )

(define-condition resolver-wrong-schema (error)
  ((suppose-name :initarg :suppose-name :accessor suppose-name)
   (actually-name :initarg :actually-name :accessor actually-name))
  (:report
   (lambda (condition stream)
	 (format stream "suppose resolve the ~a schema, but receive ~a"
			 (suppose-name condition) (actually-name condition)))))

;; (define-condition is-not-struct (error)
;;   ((incorrect-sym :initarg :incorrect-sym
;; 				  :initform nil
;; 				  :accessor incorrect-sym))
;;   (:report (lambda (condition stream)
;; 			 (format stream "the symbol '~a isn't a structure" (incorrect-sym condition)))))

;; (defun check-if-symbol-is-struct (sym)
;;   (if (not (subtypep sym 'structure-object))
;; 	  (error 'is-not-struct :incorrect-sym sym)
;; 	  t))
