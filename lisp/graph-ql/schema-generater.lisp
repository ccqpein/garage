(defclass query-schema ()
  (
   (fields
	:initarg :fields
	:accessor fields)
   )
  (:documentation "the root query schema class"))

(defclass mutation-schema ()
  (
   fields
   )
  (:documentation "the root mutation schema class")
  )

;; (defmacro generate-query-schema (s)
;;   "generate the query schema for structure"
;;   `(progn
;; 	 (check-if-symbol-is-struct ,s)
	 
;; 	 )
;;   )

(defmacro defstruct-with-query-schema (name-and-options &rest slot-descriptions)
  "defstruct and generate the query schema"
  ;;:= DEL: (format t "~a ~{~a~}" name-and-options slot-descriptions)
  (let (name fields)
	(if (consp name-and-options)
		(setf name (car name-and-options))
		(setf name name-and-options))

	(loop for f in slot-descriptions
		  if (consp f)
			do (push (car f) fields)
		  else
			do (push f fields))
	
	;;:= DEL: (format t "~a ~{~a,~}" name fields)
	(let ((schema-class-name (read-from-string (str:concat (symbol-name name) "-QUERY-SCHEMA"))))
	 `(progn
		(defstruct ,name-and-options ,@slot-descriptions)
	   
		(defclass ,schema-class-name (query-schema)
		  (
		   (data-fetcher
			:accessor data-fetcher
			:documentation "function for fetching the data")

		   (filter
			:accessor filter
			:documentation "function for filtering data after fetched")

		   (arguments
			:accessor arguments
			:initform ',fields
			:documentation "arguments can used to filter results, default is all struct fields")
		   )
		  
		  (:documentation ,(format nil "autogenerated query-schema for ~a" name)))

		;; (defparameter ,(read-from-string (str:concat "*" (symbol-name name) "-QUERY-SCHEMA*"))
		;; 	 (make-instance ',(read-from-string (str:concat (symbol-name name) "-QUERY-SCHEMA"))
		;; 					:fields ,(reverse fields))
		;; 	 ,(format nil "auto-generated query-schema for ~a" name))

		(defmethod query ((s ,schema-class-name) &rest keys &key ,@fields &allow-other-keys)
		  ;; fetch the data, set fetcher with query :before method
		  ;; filter the data
		  ;;(apply (filter s) data keys)
		  )
		))
	)
  
  )

(defmacro generate-mutation-schema ()
  "generate the mutation schema for structure"
  ;;:= todo
  )

(define-condition is-not-struct (error)
  ((incorrect-sym :initarg :incorrect-sym
				  :initform nil
				  :accessor incorrect-sym))
  (:report (lambda (condition stream)
			 (format stream "the symbol '~a isn't a structure" (incorrect-sym condition)))))

(defun check-if-symbol-is-struct (sym)
  (if (not (subtypep sym 'structure-object))
	  (error 'is-not-struct :incorrect-sym sym)
	  t))
