(defclass query-schema ()
  (
   (fields
	:initarg :fields
	:accessor fields)
   )
  (:documentation "the root query schema class"))

(defclass mutation-schema ()
  (
   (fields
	:initarg :fields
	:accessor fields)
   )
  (:documentation "the root mutation schema class")
  )


(defmacro defstruct-with-query-schema (name-and-options &rest slot-descriptions)
  "defstruct and generate the query schema"
  (let (name fields)
	(if (consp name-and-options)
		(setf name (car name-and-options))
		(setf name name-and-options))

	(loop for f in slot-descriptions
		  if (consp f)
			do (push (car f) fields)
		  else
			do (push f fields))
	
	(let ((schema-class-name (read-from-string (str:concat (symbol-name name) "-QUERY-SCHEMA"))))
	  `(progn
		 (defstruct ,name-and-options ,@slot-descriptions)
	   
		 (defclass ,schema-class-name (query-schema)
		   (
			(data-fetcher
			 :initarg :data-fetcher
			 :accessor data-fetcher
			 :documentation "function for fetching the data")

			(filter
			 :initarg :filter
			 :accessor filter
			 :documentation "function for filtering data after fetched")
			)
		  
		   (:documentation ,(format nil "autogenerated query-schema for ~a" name)))

		 (defmethod query ((s ,schema-class-name)
						   &rest keys
						   &key ,@fields &allow-other-keys)
		   ;; fetch the data, set fetcher with query
		   ;; want cache? use :before query method
		   (let* ((data (apply (data-fetcher s) keys))
				  ;; filter the data
				  (results (apply (filter s) data keys)))
			 results)
		   )

		 (defmethod resolver ((s ,schema-class-name) (bk block-scanner))
		   "parse the scaner block of received schema to data-filter"
		   ;; (do* ((tokens (tokens bk) (cdr tokens))
		   ;; 		 (tkn (car tokens) (car tokens)))
		   ;; 		())
		   )
		 ))))

(defmacro generate-mutation-schema ()
  "generate the mutation schema for structure"
  ;;:= todo
  )

;; (define-condition is-not-struct (error)
;;   ((incorrect-sym :initarg :incorrect-sym
;; 				  :initform nil
;; 				  :accessor incorrect-sym))
;;   (:report (lambda (condition stream)
;; 			 (format stream "the symbol '~a isn't a structure" (incorrect-sym condition)))))

;; (defun check-if-symbol-is-struct (sym)
;;   (if (not (subtypep sym 'structure-object))
;; 	  (error 'is-not-struct :incorrect-sym sym)
;; 	  t))
