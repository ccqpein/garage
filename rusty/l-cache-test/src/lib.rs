// Include the constant generated by build.rs
include!(concat!(env!("OUT_DIR"), "/constants.rs"));

// A large dataset size
const DATA_SIZE: usize = 1_000_000;

/// Function A: Row-major traversal (Friendly to L1 Cache)
/// Accesses memory sequentially [0, 1, 2...], allowing the CPU to pre-fetch data.
pub fn fast_sequential_access(data: &[u8]) -> u64 {
    let mut sum: u64 = 0;
    for i in 0..data.len() {
        sum = sum.wrapping_add(data[i] as u64);
    }
    sum
}

/// Function B: Stride traversal (Hostile to L1 Cache)
/// Jumps around memory, causing "Cache Misses".
pub fn slow_strided_access(data: &[u8]) -> u64 {
    let mut sum: u64 = 0;
    // We jump by the size of the L1 cache. This ensures we constantly
    // evict data from the cache, forcing the CPU to fetch from slower RAM.
    let step = L1_CACHE_SIZE;

    for i in (0..data.len()).step_by(step) {
        // Simple safety check to stay in bounds
        if i < data.len() {
            sum = sum.wrapping_add(data[i] as u64);
        }
    }
    sum
}

// Helper to create data for the benchmark
pub fn create_data() -> Vec<u8> {
    vec![1u8; DATA_SIZE]
}
